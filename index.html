<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inferno Design ‚Äî Circle IX</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="none" stroke="orange" stroke-width="2"/><line x1="12" y1="8" x2="12" y2="16" stroke="orange" stroke-width="2"/><line x1="8" y1="12" x2="16" y2="12" stroke="orange" stroke-width="2"/></svg>'), auto;
        }
        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        .circle-link {
            position: absolute;
            border-radius: 50%;
            cursor: pointer;
            z-index: 2;
        }
        #textBoxesContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
        }
        #textBoxesContainer a {
            pointer-events: auto;
            position: absolute;
            color: white;
            font-family: 'Arial Black', sans-serif;
            font-weight: bold;
            text-shadow: 
                0 0 8px #ff0,
                0 0 16px #f80,
                0 0 24px #f00;
            text-decoration: none;
            transition: all 0.3s ease;
            padding: 8px 16px;
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            backdrop-filter: blur(4px);
            font-size: 1.4em;
        }
        #textBoxesContainer a:hover {
            transform: scale(1.2) translateY(-5px);
            text-shadow: 
                0 0 12px #fff,
                0 0 24px #ff8,
                0 0 36px #ff0,
                0 0 48px #f80;
            background: rgba(50,0,0,0.7);
        }

        /* Audio control toggle */
        #audioToggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255,100,0,0.3);
            border: 2px solid #ff5500;
            color: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s;
        }
        #audioToggle:hover {
            background: rgba(255,180,0,0.5);
            transform: scale(1.1);
        }
    </style>
</head>
<body>
<canvas id="infernoCanvas"></canvas>
<div id="textBoxesContainer"></div>
<div id="audioToggle">üîä</div>

<script>
// üîä AUDIO SETUP
const audioContext = new (window.AudioContext || window.webkitAudioContext)();
let isAudioPlaying = false;
let mainGainNode = null;
let noiseBuffer = null;

// Generate white noise buffer for fire
function generateNoiseBuffer(duration = 2.0) {
    const sampleRate = audioContext.sampleRate;
    const length = sampleRate * duration;
    const buffer = audioContext.createBuffer(1, length, sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < length; i++) {
        data[i] = Math.random() * 2 - 1;
    }
    return buffer;
}

// Create fire sound: low-pass filtered noise + pops
function createFireSound() {
    const source = audioContext.createBufferSource();
    source.buffer = noiseBuffer || (noiseBuffer = generateNoiseBuffer(3));

    const gainNode = audioContext.createGain();
    gainNode.gain.value = 0.05; // Quiet base

    const filter = audioContext.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 800;
    filter.Q.value = 1;

    source.connect(filter);
    filter.connect(gainNode);
    gainNode.connect(audioContext.destination);

    source.loop = true;
    source.start(0);

    // Random fire crackles (pops)
    function addCrackle() {
        if (!isAudioPlaying) return;
        const crackle = audioContext.createOscillator();
        const crackleGain = audioContext.createGain();
        crackle.type = 'square';
        crackle.frequency.setValueAtTime(200 + Math.random() * 800, audioContext.currentTime);
        crackleGain.gain.setValueAtTime(0.2, audioContext.currentTime);
        crackleGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
        crackle.connect(crackleGain);
        crackleGain.connect(audioContext.destination);
        crackle.start();
        crackle.stop(audioContext.currentTime + 0.1);
        setTimeout(addCrackle, 500 + Math.random() * 2000);
    }

    setTimeout(addCrackle, 1000);
    return { source, gainNode };
}

// üéõÔ∏è Audio toggle
const audioToggle = document.getElementById('audioToggle');
audioToggle.addEventListener('click', async () => {
    if (audioContext.state === 'suspended') {
        await audioContext.resume();
    }

    if (!isAudioPlaying) {
        // Start audio
        mainGainNode = createFireSound().gainNode;
        isAudioPlaying = true;
        audioToggle.textContent = 'üîá';
        audioToggle.style.background = 'rgba(200,50,0,0.5)';
    } else {
        // Stop audio
        if (mainGainNode) {
            mainGainNode.gain.setValueAtTime(mainGainNode.gain.value, audioContext.currentTime);
            mainGainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
        }
        isAudioPlaying = false;
        audioToggle.textContent = 'üîä';
        audioToggle.style.background = 'rgba(255,100,0,0.3)';
        setTimeout(() => {
            if (audioContext && audioContext.state !== 'closed') {
                // Audio keeps playing silently; we‚Äôll rely on gain fade.
            }
        }, 600);
    }
});

// üé® CANVAS SETUP
const canvas = document.getElementById("infernoCanvas");
const ctx = canvas.getContext("2d");

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const centerX = canvas.width / 2;
const centerY = canvas.height / 2;

// Circles (Sins)
const outerRadius = 230;
const innerCircles = [
    { x: centerX,     y: centerY - 140, radius: 75, originalRadius: 75, image: null, url: 'sin5.html', sinName: 'Sin 5' },
    { x: centerX - 120, y: centerY - 40, radius: 70, originalRadius: 70, image: null, url: 'sin4.html', sinName: 'Sin 4' },
    { x: centerX - 70, y: centerY + 100, radius: 65, originalRadius: 65, image: null, url: 'sin2.html', sinName: 'SIn 3' },
    { x: centerX + 70, y: centerY + 100, radius: 60, originalRadius: 60, image: null, url: 'sin3.html', sinName: 'Sin 2' },
    { x: centerX + 120, y: centerY - 40, radius: 55, originalRadius: 55, image: null, url: 'sin1.html', sinName: 'Sin 1' }
];

// Load image (fixed URL)
const imgUrl = 'https://i.postimg.cc/SKcBmXyr/image-1-1764408526209.png';
innerCircles.forEach((circle, i) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.src = imgUrl;
    img.onload = () => { circle.image = img; };
    img.onerror = () => console.warn(`Image ${i} failed.`);
});

// UI links
innerCircles.forEach(c => {
    const link = document.createElement('a');
    link.href = c.url;
    link.className = 'circle-link';
    document.body.appendChild(link);
    c.linkEl = link;
    c.updateLink = () => {
        link.style.width = link.style.height = (c.radius * 2) + 'px';
        link.style.left = (c.x - c.radius) + 'px';
        link.style.top = (c.y - c.radius) + 'px';
    };
});

// Text labels
const textBoxesContainer = document.getElementById('textBoxesContainer');
innerCircles.forEach(c => {
    const a = document.createElement('a');
    a.href = c.url;
    a.innerText = c.sinName;
    textBoxesContainer.appendChild(a);
    c.textEl = a;
    c.updateText = () => {
        let left = c.x, top = c.y - c.radius - 45;
        if (c.sinName === 'Lust') left -= 60;
        else if (c.sinName === 'Gluttony') { left -= 30; top = c.y + c.radius + 10; }
        else if (c.sinName === 'Greed') { left = c.x - c.radius - 40; top = c.y + 5; }
        else if (c.sinName === 'Pride') { left = c.x + c.radius + 10; top = c.y - 20; }
        a.style.left = `${left}px`;
        a.style.top = `${top}px`;
    };
});

// üî• Particles
const particles = [];
function createParticles() {
    particles.length = 0;
    for (let i = 0; i < 150; i++) {
        const type = Math.random() > 0.7 ? 'smoke' : (Math.random() > 0.9 ? 'ash' : 'flame');
        particles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height + canvas.height,
            vx: (Math.random() - 0.5) * 0.8,
            vy: -Math.random() * 1.5 - 0.3,
            life: Math.random() * 80 + 20,
            maxLife: 100,
            size: Math.random() * 4 + 2,
            type: type,
            hue: 10 + Math.random() * 30
        });
    }
}
createParticles();

// üëπ DEMON FACES ‚Äî subtle, eerie, blinking
const demonFaces = [];
for (let i = 0; i < 8; i++) {
    demonFaces.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height * 0.6, // top 60%
        size: 80 + Math.random() * 60,
        blinkPhase: Math.random() * Math.PI * 2,
        grimace: Math.random() > 0.5,
        appearTime: Math.random() * 10
    });
}

// Noise function (for texture)
function noise(x, y) {
    return Math.sin(x * 0.1) * Math.cos(y * 0.13) + 
           Math.sin(x * 0.23) * Math.cos(y * 0.17) + 
           Math.sin(x * 0.31 + y * 0.29);
}

// üå™Ô∏è VORTEX PARAMETERS
let vortexAngle = 0;
let flicker = 0, flickerDir = 1;
let time = 0;
let mouseX = centerX, mouseY = centerY;
document.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });

// üî• MAIN RENDER LOOP
function drawBackground() {
    time += 0.02;
    vortexAngle += 0.001; // slow rotation

    // === Layer 0: Deep Vortex ===
    const vortexCenterX = centerX + Math.sin(time * 0.3) * 50;
    const vortexCenterY = centerY + Math.cos(time * 0.25) * 40;
    
    const vortexGrad = ctx.createRadialGradient(vortexCenterX, vortexCenterY, 50, vortexCenterX, vortexCenterY, canvas.width);
    vortexGrad.addColorStop(0, `rgba(30, 0, 0, 0.9)`);
    vortexGrad.addColorStop(0.6, `rgba(80, 0, 0, 0.7)`);
    vortexGrad.addColorStop(1, `rgba(5, 0, 0, 1)`);
    ctx.fillStyle = vortexGrad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Spiral arms (subtle)
    ctx.strokeStyle = 'rgba(100, 0, 0, 0.2)';
    ctx.lineWidth = 2;
    for (let arm = 0; arm < 5; arm++) {
        ctx.beginPath();
        for (let r = 100; r < canvas.width * 1.2; r += 15) {
            const a = vortexAngle + arm * Math.PI * 0.4 + r * 0.02;
            const x = vortexCenterX + Math.cos(a) * r;
            const y = vortexCenterY + Math.sin(a) * r;
            if (r === 100) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
    }

    // === Layer 1: Hellstone + DEMON FACES ===
    ctx.globalAlpha = 0.08;
    for (let y = 0; y < canvas.height * 0.7; y += 12) { // only top 70%
        for (let x = 0; x < canvas.width; x += 12) {
            const n = noise(x + time * 15, y + time * 8) * 0.5 + 0.5;
            let shade = 15 + n * 10;
            
            // Check if near a demon face ‚Äî darken for silhouette
            let nearDemon = false;
            for (const d of demonFaces) {
                const dx = x - d.x, dy = y - d.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < d.size * 0.6) {
                    nearDemon = true;
                    break;
                }
            }
            if (nearDemon) shade *= 0.6;

            ctx.fillStyle = `hsl(${10 + n * 20}, 50%, ${shade}%)`;
            ctx.fillRect(x, y, 12, 12);
        }
    }
    ctx.globalAlpha = 1;

    // Draw demon faces (eyes & mouth only ‚Äî implied horror)
    demonFaces.forEach(d => {
        const appear = Math.sin(time - d.appearTime) * 0.5 + 0.5;
        if (appear < 0.1) return; // fade in/out

        ctx.save();
        ctx.translate(d.x, d.y);
        ctx.globalAlpha = appear * 0.7;

        // Eyes (blink)
        const blink = Math.sin(time * 3 + d.blinkPhase) > 0.8 ? 0 : 1; // quick blinks
        ctx.fillStyle = '#ff2200';
        ctx.beginPath();
        ctx.arc(-d.size * 0.2, -d.size * 0.15, d.size * 0.12 * blink, 0, Math.PI * 2);
        ctx.arc(d.size * 0.2, -d.size * 0.15, d.size * 0.12 * blink, 0, Math.PI * 2);
        ctx.fill();

        // Mouth (grimace or smirk)
        ctx.strokeStyle = '#aa0000';
        ctx.lineWidth = 3;
        ctx.beginPath();
        if (d.grimace) {
            // üò† Angry grimace
            ctx.arc(0, d.size * 0.1, d.size * 0.2, Math.PI * 0.1, Math.PI * 0.9, false);
        } else {
            // üòè Smirk
            ctx.moveTo(-d.size * 0.25, d.size * 0.05);
            ctx.quadraticCurveTo(0, d.size * 0.25, d.size * 0.25, d.size * 0.05);
        }
        ctx.stroke();

        ctx.restore();
    });

    // === Layer 2: Lava Floor ===
    const lavaHeight = canvas.height * 0.25;
    const lavaGrad = ctx.createLinearGradient(0, canvas.height - lavaHeight, 0, canvas.height);
    lavaGrad.addColorStop(0, 'rgba(220, 30, 0, 0.2)');
    lavaGrad.addColorStop(0.4, 'rgba(255, 60, 0, 0.5)');
    lavaGrad.addColorStop(1, 'rgba(255, 120, 0, 0.85)');
    ctx.fillStyle = lavaGrad;
    ctx.fillRect(0, canvas.height - lavaHeight, canvas.width, lavaHeight);

    // Lava ripples
    ctx.strokeStyle = 'rgba(255, 180, 0, 0.3)';
    ctx.lineWidth = 2;
    for (let i = 0; i < 6; i++) {
        ctx.beginPath();
        const y = canvas.height - lavaHeight + Math.sin(time * 2.5 + i) * 18 + i * 30;
        ctx.moveTo(0, y);
        for (let x = 0; x <= canvas.width; x += 25) {
            const yOffset = Math.sin(x * 0.03 + time * 3.5 + i) * 10;
            ctx.lineTo(x, y + yOffset);
        }
        ctx.stroke();
    }

    // === Layer 3: Core Glow + Heat ===
    const coreGlow = ctx.createRadialGradient(centerX, centerY, 100, centerX, centerY, 500);
    coreGlow.addColorStop(0, `rgba(255, 100, 0, ${0.35 + Math.sin(time * 2) * 0.08})`);
    coreGlow.addColorStop(0.8, `rgba(150, 10, 0, 0.05)`);
    coreGlow.addColorStop(1, 'transparent');
    ctx.fillStyle = coreGlow;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // === Particles ===
    particles.forEach(p => {
        const age = 1 - p.life / p.maxLife;
        let r, g, b, a;
        if (p.type === 'flame') {
            r = 255; g = 200 - age * 120; b = 40; a = 0.7 - age * 0.5;
            p.size = 3 + age * 5;
        } else if (p.type === 'smoke') {
            r = g = b = 20 + age * 50; a = 0.08 + age * 0.15;
            p.size = 10 + age * 15;
            p.vx *= 0.98;
        } else {
            r = 60; g = 40; b = 10; a = 0.25 - age * 0.2;
            p.size = 2 + age * 2;
        }

        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
        ctx.fill();

        p.x += p.vx;
        p.y += p.vy;
        p.life--;

        if (p.life <= 0) {
            p.x = Math.random() * canvas.width;
            p.y = canvas.height + 10;
            p.life = p.maxLife;
            p.type = Math.random() > 0.7 ? 'smoke' : (Math.random() > 0.9 ? 'ash' : 'flame');
        }
    });
}

function drawOuterCircle() {
    ctx.beginPath();
    ctx.arc(centerX, centerY, outerRadius, 0, Math.PI * 2);
    
    const ringGrad = ctx.createRadialGradient(centerX, centerY, outerRadius - 30, centerX, centerY, outerRadius + 40);
    ringGrad.addColorStop(0, 'rgba(70, 0, 0, 0.7)');
    ringGrad.addColorStop(0.7, 'rgba(200, 40, 0, 0.95)');
    ringGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = ringGrad;
    ctx.fill();

    // Pulse
    flicker += 0.8 * flickerDir;
    if (flicker > 45 || flicker < -25) flickerDir *= -1;

    ctx.strokeStyle = `rgba(255, ${160 + flicker}, 0, 1)`;
    ctx.lineWidth = 8;
    ctx.shadowColor = `rgba(255, 80, 0, 0.9)`;
    ctx.shadowBlur = 45 + Math.sin(time * 3) * 12;
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Organic cracks
    ctx.strokeStyle = '#220000';
    ctx.lineWidth = 2;
    for (let i = 0; i < 14; i++) {
        ctx.beginPath();
        const baseAngle = (i / 14) * Math.PI * 2 + time * 0.07;
        let x = centerX + Math.cos(baseAngle) * (outerRadius * 0.65);
        let y = centerY + Math.sin(baseAngle) * (outerRadius * 0.65);
        ctx.moveTo(x, y);
        for (let j = 0; j < 10; j++) {
            const angle = baseAngle + (Math.random() - 0.5) * 2;
            const len = 12 + Math.random() * 25;
            x += Math.cos(angle) * len;
            y += Math.sin(angle) * len;
            ctx.lineTo(x, y);
        }
        ctx.stroke();
    }
}

function drawInnerCircles() {
    innerCircles.forEach(c => {
        const dx = mouseX - c.x;
        const dy = mouseY - c.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const isHover = dist < c.radius * 1.4;
        c.radius = isHover ? c.originalRadius * 1.35 : c.originalRadius;

        c.updateLink();
        c.updateText();

        ctx.save();
        ctx.beginPath();
        ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2);
        ctx.clip();

        if (c.image) {
            ctx.drawImage(c.image, c.x - c.radius, c.y - c.radius, c.radius*2, c.radius*2);
        } else {
            const g = ctx.createRadialGradient(c.x, c.y, 5, c.x, c.y, c.radius);
            g.addColorStop(0, "#ffd500");
            g.addColorStop(0.6, "#ff5500");
            g.addColorStop(1, "#aa0000");
            ctx.fillStyle = g;
            ctx.fill();
        }

        ctx.restore();

        ctx.beginPath();
        ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2);
        ctx.lineWidth = isHover ? 9 : 6;
        ctx.strokeStyle = isHover ? "#ffcc00" : "#ff8800";
        ctx.shadowColor = isHover ? "#ff7700" : "#ff4400";
        ctx.shadowBlur = isHover ? 50 : 30;
        ctx.stroke();
        ctx.shadowBlur = 0;

        // Flames
        const flameCount = isHover ? 14 : 10;
        for (let i = 0; i < flameCount; i++) {
            const angle = (i / flameCount) * Math.PI * 2 + time * 1.8;
            const baseX = c.x + Math.cos(angle) * (c.radius + 5);
            const baseY = c.y + Math.sin(angle) * (c.radius + 5);
            
            ctx.beginPath();
            ctx.moveTo(baseX, baseY);
            const tipX = baseX + Math.cos(angle + Math.sin(time + i) * 0.6) * (28 + Math.sin(time * 2.5 + i) * 12);
            const tipY = baseY + Math.sin(angle + Math.sin(time + i) * 0.6) * (28 + Math.sin(time * 2.5 + i) * 12) - 18;
            ctx.quadraticCurveTo(
                baseX + Math.cos(angle + 0.4) * 20,
                baseY - 12,
                tipX, tipY
            );
            const alpha = 0.7 + Math.sin(time * 6 + i) * 0.25;
            ctx.strokeStyle = `rgba(255, ${190 + Math.sin(time + i) * 25}, 0, ${alpha})`;
            ctx.lineWidth = isHover ? 4 : 3;
            ctx.stroke();
        }
    });
}

function drawText() {
    ctx.textAlign = "center";
    ctx.font = "bold 110px 'Arial Black', sans-serif";
    const flick = 0.75 + Math.sin(time * 4.5) * 0.25;
    ctx.fillStyle = `rgba(255, ${190 * flick}, 50, 1)`;
    ctx.shadowColor = `rgba(255, 100, 0, 1)`;
    ctx.shadowBlur = 70;
    ctx.fillText("INFERNO", centerX, centerY - 250);
    ctx.shadowBlur = 0;


}

// üéûÔ∏è ANIMATION
function animate() {
    drawBackground();
    drawOuterCircle();
    drawInnerCircles();
    drawText();
    requestAnimationFrame(animate);
}

// Start
setTimeout(() => {
    animate();
    // Auto-start audio on first user gesture (via toggle button)

}, 100);
</script>
</body>
</html>